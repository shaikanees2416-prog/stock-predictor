# --- ADVANCED STOCK DIRECTION CLASSIFIER + ENHANCED BACKTEST ---
#
# UPGRADES:
# 1. New Features: Average True Range (ATR) and Average Directional Index (ADX)
#    for better understanding of volatility and trend strength.
# 2. Better Model: XGBoost Classifier with Early Stopping to improve accuracy
#    and prevent overfitting.
# 3. Enhanced Analysis: More detailed backtest metrics (Sortino, Calmar, Win Rate)
#    and a plot of the strategy's drawdown.
#
# To run, you need to install/upgrade the following libraries:
# pip install yfinance pandas numpy scikit-learn matplotlib seaborn xgboost

import yfinance as yf
import pandas as pd
import numpy as np
import xgboost as xgb
from sklearn.metrics import classification_report, accuracy_score, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns
from math import sqrt
import warnings
warnings.filterwarnings("ignore")

# -------------------------
# User params
# -------------------------
TICKER = "AAPL"
START_DATE = "2015-01-01"
END_DATE = "2025-09-16" # Updated to near current date
TEST_SIZE_RATIO = 0.20
RANDOM_STATE = 42

# -------------------------
# Helper functions
# -------------------------
def compute_indicators(df):
    """Add technical indicators and lagged features. Works inplace."""
    # Basic returns
    df['Return'] = df['Close'].pct_change()

    # Simple Moving Averages
    df['SMA_10'] = df['Close'].rolling(window=10).mean()
    df['SMA_50'] = df['Close'].rolling(window=50).mean()

    # RSI (14)
    delta = df['Close'].diff(1)
    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    rs = gain / loss
    df['RSI'] = 100 - (100 / (1 + rs))

    # MACD
    exp12 = df['Close'].ewm(span=12, adjust=False).mean()
    exp26 = df['Close'].ewm(span=26, adjust=False).mean()
    df['MACD'] = exp12 - exp26
    df['MACD_signal'] = df['MACD'].ewm(span=9, adjust=False).mean()

    # Bollinger Bands (20)
    df['MA20'] = df['Close'].rolling(window=20).mean()
    rolling_std_20 = df['Close'].rolling(window=20).std()
    df['BB_up'] = df['MA20'] + (2 * rolling_std_20)
    df['BB_low'] = df['MA20'] - (2 * rolling_std_20)
    df['BB_width'] = (df['BB_up'] - df['BB_low']) / df['MA20']

    # --- NEW FEATURE 1: Average True Range (ATR) for Volatility ---
    high_low = df['High'] - df['Low']
    high_close = np.abs(df['High'] - df['Close'].shift())
    low_close = np.abs(df['Low'] - df['Close'].shift())
    ranges = pd.concat([high_low, high_close, low_close], axis=1)
    true_range = np.max(ranges, axis=1)
    df['ATR'] = true_range.rolling(14).mean()

    # --- NEW FEATURE 2: Average Directional Index (ADX) for Trend Strength ---
    plus_dm = np.where((df['High'] - df['High'].shift(1)) > (df['Low'].shift(1) - df['Low']), df['High'] - df['High'].shift(1), 0)
    minus_dm = np.where((df['Low'].shift(1) - df['Low']) > (df['High'] - df['High'].shift(1)), df['Low'].shift(1) - df['Low'], 0)
    tr14 = true_range.rolling(14).sum()
    plus_di = 100 * (pd.Series(plus_dm).rolling(14).sum() / tr14)
    minus_di = 100 * (pd.Series(minus_dm).rolling(14).sum() / tr14)
    dx = 100 * (np.abs(plus_di - minus_di) / (plus_di + minus_di))
    df['ADX'] = dx.rolling(14).mean()
    
    # OBV, Momentum, Lags
    price_change_sign = np.sign(df['Close'].diff()).fillna(0)
    df['OBV'] = (df['Volume'] * price_change_sign).cumsum()
    df['Momentum_10'] = df['Close'].pct_change(periods=10)
    df['Lag1'] = df['Return'].shift(1)
    df['Lag2'] = df['Return'].shift(2)

    # Forward return for backtest
    df['Forward_Return'] = df['Close'].shift(-1) / df['Close'] - 1
    return df

def max_drawdown(cum_returns):
    roll_max = cum_returns.cummax()
    drawdown = cum_returns / roll_max - 1
    return drawdown.min()

# -------------------------
# 1) Download and Prepare Data
# -------------------------
print(f"Downloading {TICKER} data from {START_DATE} to {END_DATE} ...")
data = yf.download(TICKER, start=START_DATE, end=END_DATE)
if data.empty:
    raise SystemExit(f"No data for {TICKER}. Check ticker/date range.")

print("Engineering features...")
data = compute_indicators(data)
data['Target'] = np.where(data['Close'].shift(-1) > data['Close'], 1, 0)
data.dropna(inplace=True)
data['Target'] = data['Target'].astype(int)

# -------------------------
# 2) Select Features & Split Data
# -------------------------
features = [
    'SMA_10', 'SMA_50', 'RSI', 'MACD', 'MACD_signal', 'BB_width', 'OBV',
    'Momentum_10', 'Lag1', 'Lag2', 'Volume',
    'ATR',  # New volatility feature
    'ADX'   # New trend strength feature
]
X = data[features]
y = data['Target']

split_index = int(len(X) * (1 - TEST_SIZE_RATIO))
X_train_full, X_test = X.iloc[:split_index], X.iloc[split_index:]
y_train_full, y_test = y.iloc[:split_index], y.iloc[split_index:]

# Further split training data for early stopping
train_val_split_index = int(len(X_train_full) * 0.8)
X_train, X_val = X_train_full.iloc[:train_val_split_index], X_train_full.iloc[train_val_split_index:]
y_train, y_val = y_train_full.iloc[:train_val_split_index], y_train_full.iloc[train_val_split_index:]

print(f"Full data shape:   {X.shape}")
print(f"Training set shape:  {X_train.shape}")
print(f"Validation set shape:{X_val.shape}")
print(f"Testing set shape:   {X_test.shape}")

# -------------------------
# 3) Train UPGRADED MODEL (XGBoost with Early Stopping)
# -------------------------
print("\nTraining XGBoostClassifier with Early Stopping...")
model = xgb.XGBClassifier(
    objective='binary:logistic',
    eval_metric='logloss',
    n_estimators=1000,          # We set a high number, early stopping will find the best one
    learning_rate=0.05,
    max_depth=5,
    subsample=0.8,
    colsample_bytree=0.8,
    use_label_encoder=False,
    random_state=RANDOM_STATE
)

model.fit(
    X_train, y_train,
    early_stopping_rounds=50,  # Stop if validation loss doesn't improve for 50 rounds
    eval_set=[(X_val, y_val)],
    verbose=False
)
print("Model training complete.\n")

# -------------------------
# 4) Evaluate Classification Performance
# -------------------------
print("--- Evaluating The Model ---")
y_pred = model.predict(X_test)
accuracy = accuracy_score(y_test, y_pred)

print(f"Optimal number of trees found: {model.best_iteration}")
print(f"Accuracy Score: {accuracy:.4f}")
print("\nClassification Report:")
print(classification_report(y_test, y_pred, target_names=['Down (0)', 'Up (1)']))
cm = confusion_matrix(y_test, y_pred)

# -------------------------
# 5) ENHANCED BACKTEST ANALYSIS
# -------------------------
print("\n--- Running Enhanced Backtest on Test Set ---")
pred_series = pd.Series(y_pred, index=X_test.index, name='Prediction')
forward_ret = data['Forward_Return'].loc[pred_series.index]
raw_strategy_ret = pred_series * forward_ret
cost_per_trade = 0.001
prev_signal = pred_series.shift(1).fillna(0).astype(int)
entry = ((pred_series == 1) & (prev_signal == 0)).astype(int)
strategy_ret_net = (raw_strategy_ret - (entry * cost_per_trade)).dropna()
forward_ret = forward_ret.loc[strategy_ret_net.index]

# Equity curves
strategy_eq = (1 + strategy_ret_net).cumprod()
buyhold_eq = (1 + forward_ret).cumprod()

# --- Advanced Metrics ---
n_days = len(strategy_ret_net)
trades = entry.sum()
strategy_total_return = strategy_eq.iloc[-1] - 1
buyhold_total_return = buyhold_eq.iloc[-1] - 1
ann_return_strategy = (1 + strategy_total_return) ** (252 / n_days) - 1
ann_vol_strategy = strategy_ret_net.std() * sqrt(252)
sharpe_strategy = ann_return_strategy / ann_vol_strategy if ann_vol_strategy != 0 else 0
mdd_strategy = max_drawdown(strategy_eq)
calmar_strategy = ann_return_strategy / abs(mdd_strategy) if mdd_strategy != 0 else 0
downside_dev = strategy_ret_net[strategy_ret_net < 0].std() * sqrt(252)
sortino_strategy = ann_return_strategy / downside_dev if downside_dev != 0 else 0
trade_returns = forward_ret[pred_series == 1]
win_rate = (trade_returns > 0).mean() if not trade_returns.empty else 0
avg_win = trade_returns[trade_returns > 0].mean() if win_rate > 0 else 0
avg_loss = trade_returns[trade_returns < 0].mean() if win_rate < 1 else 0
profit_factor = abs(trade_returns[trade_returns > 0].sum() / trade_returns[trade_returns < 0].sum()) if trade_returns[trade_returns < 0].sum() != 0 else float('inf')


print(f"\nBacktest Period: {strategy_ret_net.index[0].date()} to {strategy_ret_net.index[-1].date()} ({n_days} days)")
print(f"Number of entry trades: {trades}")
print("-" * 40)
print(f"                | {'Strategy':>12} | {'Buy & Hold':>12}")
print("-" * 40)
print(f"Total Return    | {strategy_total_return:12.2%} | {buyhold_total_return:12.2%}")
print(f"Annual. Return  | {ann_return_strategy:12.2%} |")
print(f"Annual. Vol     | {ann_vol_strategy:12.2%} |")
print(f"Max Drawdown    | {mdd_strategy:12.2%} |")
print("-" * 40)
print("Risk-Adjusted Ratios (Strategy):")
print(f"Sharpe Ratio: {sharpe_strategy:.2f}")
print(f"Sortino Ratio: {sortino_strategy:.2f} (penalizes only downside volatility)")
print(f"Calmar Ratio: {calmar_strategy:.2f} (return vs. max drawdown)")
print("-" * 40)
print("Trade Analysis (Strategy):")
print(f"Win Rate: {win_rate:.2%}")
print(f"Avg. Win / Trade: {avg_win:.4f}")
print(f"Avg. Loss / Trade: {avg_loss:.4f}")
print(f"Profit Factor: {profit_factor:.2f}")
print("-" * 40)

# -------------------------
# 6) Visualizations
# -------------------------
# Equity Curve
plt.style.use('seaborn-v0_8-darkgrid')
fig, ax1 = plt.subplots(figsize=(14, 8))
ax1.plot(strategy_eq.index, strategy_eq, label='XGBoost Strategy Equity', color='royalblue', linewidth=2)
ax1.plot(buyhold_eq.index, buyhold_eq, label='Buy & Hold Equity', color='gray', linestyle='--')
ax1.set_title(f'Equity Curve & Drawdown â€” {TICKER}', fontsize=16)
ax1.set_xlabel('Date')
ax1.set_ylabel('Cumulative Return')
ax1.legend(loc='upper left')
ax1.grid(True)

# Drawdown Plot (Underwater Curve) on a secondary axis
drawdown_series = (strategy_eq / strategy_eq.cummax()) - 1
ax2 = ax1.twinx()
ax2.fill_between(drawdown_series.index, 0, drawdown_series, color='red', alpha=0.3, label='Drawdown')
ax2.set_ylabel('Drawdown', color='red')
ax2.tick_params(axis='y', labelcolor='red')
ax2.legend(loc='lower right')
plt.show()

# Confusion Matrix Heatmap
plt.figure(figsize=(7, 5))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
            xticklabels=['Predicted Down', 'Predicted Up'],
            yticklabels=['Actual Down', 'Actual Up'])
plt.title("Confusion Matrix", fontsize=14)
plt.xlabel("Predicted Label")
plt.ylabel("Actual Label")
plt.show()

# Feature Importance Plot
fig, ax = plt.subplots(figsize=(10, 7))
xgb.plot_importance(model, ax=ax, height=0.8, importance_type='gain')
plt.title('XGBoost Feature Importance (Gain)', fontsize=14)
plt.show()